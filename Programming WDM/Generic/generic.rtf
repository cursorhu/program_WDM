{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f4\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Times;}
{\f5\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helvetica;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f7\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Geneva;}
{\f8\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset0\fprq2{\*\panose 00000000000000000000}MS Serif;}
{\f11\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\froman\fcharset0\fprq2{\*\panose 00000000000000000000}New York;}{\f13\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}System;}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f15\fswiss\fcharset0\fprq3{\*\panose 020b0604030504040204}Tahoma;}{\f22\fswiss\fcharset238\fprq2 Arial CE;}{\f23\fswiss\fcharset204\fprq2 Arial Cyr;}
{\f25\fswiss\fcharset161\fprq2 Arial Greek;}{\f26\fswiss\fcharset162\fprq2 Arial Tur;}{\f27\fswiss\fcharset186\fprq2 Arial Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;
\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet{\sa160\sl240\slmult0\nowidctlpar\adjustright \fs21 \snext0 Normal;}{\s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\nowidctlpar\adjustright \b\fs40 \sbasedon0 \snext0 heading 1;}{\s2\li-1800\sb160\sa60\sl-380\slmult0
\keepn\nowidctlpar\adjustright \b\fs34 \sbasedon0 \snext0 heading 2;}{\s3\sb160\sa40\sl-340\slmult0\keepn\nowidctlpar\adjustright \b\f1\fs30 \sbasedon0 \snext0 heading 3;}{\s4\sb160\sa40\sl-280\slmult0\keepn\nowidctlpar\adjustright \b\f1 
\sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}{\s15\li-1800\sl-210\slmult0\nowidctlpar\tqr\tx6960\adjustright \b\f1\fs19 \sbasedon0 \snext15 header;}{\s16\sl-220\slmult0\nowidctlpar
\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\adjustright \f2\fs16 \snext16 Ex;}{\s17\li-1770\ri30\sb50\sl-80\slmult0\nowidctlpar\brdrt\brdrs\brdrw15\brdrcf2 \adjustright \fs12 \snext17 header rule;}{
\s18\li-1800\sa180\sl-440\slmult0\keepn\nowidctlpar\tx0\adjustright \b\f1\fs40\up8 \snext18 Rh1;}{\s19\sb20\sl-220\slmult0\keepn\nowidctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 \snext19 Rmh;}{
\s20\sl-240\slmult0\keepn\nowidctlpar\adjustright \fs21 \snext20 Term1;}{\s21\li280\sl-240\slmult0\keepn\nowidctlpar\adjustright \fs21 \snext21 Term2;}{\s22\li280\sa80\sl-240\slmult0\nowidctlpar\adjustright \fs21 \snext22 Def1;}{
\s23\li560\sa80\sl-240\slmult0\nowidctlpar\adjustright \fs21 \snext23 Def2;}{\s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\nowidctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 \snext24 Rule;}{\s25\sl240\slmult0\nowidctlpar\adjustright \fs21 
\snext25 Index Link;}{\s26\sa80\widctlpar\intbl\adjustright \fs21\lang1024 \sbasedon0 \snext26 Table Text;}}{\info{\author Walter Oney}{\operator Walter Oney}{\creatim\yr1999\mo9\dy6\hr5\min14}{\revtim\yr1999\mo9\dy6\hr5\min24}{\version2}{\edmins10}
{\nofpages25}{\nofwords4206}{\nofchars23977}{\*\company Walter Oney Software}{\nofcharsws29445}{\vern89}}\margl3330\margr1530\margt-2540\margb-2220\gutter420 \facingp\deftab280\widowctrl\ftnbj\aenddoc\hyphcaps0\viewkind4\viewscale150 \fet0\sectd 
\binfsxn1\binsxn1\linex0\headery1990\footery360\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \s15\li-1800\sl-210\slmult0\widctlpar\tqr\tx6960\adjustright \b\f1\fs19 {\field{\*\fldinst {PAGE}}{\fldrslt {\lang1024 24}}}{\expnd50\expndtw250  }{
Autoduck Output - 09/06/99
\par }\pard\plain \s17\li-1770\ri30\sb50\sl-80\slmult0\widctlpar\brdrt\brdrs\brdrw15\brdrcf2 \adjustright \fs12 {
\par }}{\headerr \pard\plain \s15\li-1800\sl-210\slmult0\widctlpar\tqr\tx6960\adjustright \b\f1\fs19 {\tab Autoduck Output - 09/06/99}{\expnd50\expndtw250   }{\field{\*\fldinst {PAGE}}{\fldrslt {\lang1024 15}}}{
\par }\pard\plain \s17\li-1770\ri30\sb50\sl-80\slmult0\widctlpar\brdrt\brdrs\brdrw15\brdrcf2 \adjustright \fs12 {
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {

\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {AbortRequests
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b AbortRequests(PDEVQUEUE}{ }{\i pdq}{\b , NTSTATUS}{ }{\i status}{\b ) }{
\par Begin rejecting new requests
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i status}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Status with which to fail new requests, for example:
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_DELETE_PENDING
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Device is being deleted
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_DEVICE_POWERED_OFF
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Device is has been powered off
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Undo the effect of this call by calling AllowRequests
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {AllowRequests
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b AllowRequests(PDEVQUEUE}{ }{\i pdq}{\b ) }{
\par Begin accepting new requests
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {This function undoes the effect of a previous call to AbortRequests
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {AreRequestsBeingAborted
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b AreRequestsBeingAborted(PDEVQUEUE}{ }{\i pdq}{\b ) }{
\par Determine if new requests are currently being rejected
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {STATUS_SUCCESS if requests aren't being aborted right now, some nonzero status code otherwise.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {CancelRequest
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b CancelRequest(PDEVQUEUE}{ }{\i pdq}{\b , PIRP}{ }{\i Irp}{\b ) }{
\par Handle cancellation of an IRP
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i Irp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {IRP that's being cancelled
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Call this function from a standard cancel routine while still owning the global cancel spin lock.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {CheckBusyAndStall
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI BOOLEAN GENERIC_EXPORT}{ }{\b CheckBusyAndStall(PDEVQUEUE}{ }{\i pdq}{\b ) }{
\par Stall queue if not currently busy
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {TRUE if device currently busy. FALSE if device not currently busy, in which case this function will also stall the queue to prevent the device from becoming busy
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {CleanupRequests
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b CleanupRequests(PDEVQUEUE}{ }{\i pdq}{\b , PFILE_OBJECT}{ }{\i fop}{\b , NTSTATUS}{ }{\i status}{\b ) }{
\par Complete requests for a given file object
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i fop}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {File object for which requests are to be completed. NULL to complete all requests on the queue
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i status}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Completion status (usually STATUS_CANCELLED)
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericCacheControlRequest
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericCacheControlRequest(PGENERIC_EXTENSION}{ }{\i pdx}{\b , PIRP}{ }{\i Irp}{\b , PIRP*}{ }{\i pIrp}{\b ) }{
\par Cache an asynchronous I/O control request
\par Defined in: D:/WDMBOOK/GENERIC/CONTROL.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Status code:
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_PENDING
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {(Normal return value) IRP has been cached for asynchronous completion
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_INVALID_DEVICE_REQUEST
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {GENERIC_PENDING_IOCTLS flag wasn't set in GENERIC_INIT_STRUCT passed to InitializeGenericExtension
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_INVALID_PARAMETER
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {IRP doesn't have a free I/O stack location
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {(other)
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {An error of some kind has occurred
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Generic.sys device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i Irp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {IRP to cache
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pIrp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Where to save pointer to cached IRP. The calling driver should not ever access this 
location directly. GENERIC.SYS only accesses it while owning a spin lock that ensures thread and multiprocessor safety.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Use this function to cache a pointer to an asynchronous I/O Control request. GENERIC.SYS will take care of completing the IRP if it's cancelled or if a PnP or Power event occurs.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {\cf6 Developer Notes
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\cf6 
This routine advances the I/O stack pointer by one location in order to install a completion routine. GenericUncacheControlRequest does *not* restore the stack pointer. If you plan to pass
 an uncached IRP down to a lower-level driver, be sure you increase the StackSize in your device object by one during your own AddDevice so the IRP will have enough stack.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericCleanupControlRequests
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b GenericCleanupControlRequests(PGENERIC_EXTENSION}{ }{\i pdx}{\b , NTSTATUS}{ }{\i status}{\b , PFILE_OBJECT}{ }{\i fop}{\b ) }{
\par Cleanup cached I/O control requests
\par Defined in: D:/WDMBOOK/GENERIC/CONTROL.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Generic.sys device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i status}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Status code to use in completing requests
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i fop}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {File object for which requests are to be completed. NULL if all cached requests for the calling driver are to be completed.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {The main purpose of this routine is to help handle an IRP_MJ_CLEANUP when the file handle may have been used to submit pending control requests.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericDeregisterInterface
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericDeregisterInterface(PGENERIC_EXTENSION}{ }{\i pdx}{\b , const GUID*}{ }{\i guid}{\b ) }{
\par Deregister a device interface
\par Defined in: D:/WDMBOOK/GENERIC/PLUGPLAY.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {One of the following standard status codes:
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_SUCCESS
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Operation was performed
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_INVALID_PARAMETER
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {No interface GUID by that name registered
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i guid}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of GUID for which an interface was previously registered
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericDispatchPnp
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericDispatchPnp(PGENERIC_EXTENSION}{ }{\i pdx}{\b , PIRP}{ }{\i Irp}{\b ) }{
\par Handle IRP_MJ_PNP
\par Defined in: D:/WDMBOOK/GENERIC/PLUGPLAY.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard completion code
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i Irp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Plug and Play request
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericDispatchPower
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericDispatchPower(PGENERIC_EXTENSION}{ }{\i pdx}{\b , PIRP}{ }{\i Irp}{\b ) }{
\par Handle IRP_MJ_POWER request
\par Defined in: D:/WDMBOOK/GENERIC/POWER.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard status code
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i Irp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Power request
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericEnableInterface
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericEnableInterface(PGENERIC_EXTENSION}{ }{\i pdx}{\b , const GUID*}{ }{\i guid}{\b , BOOLEAN}{ }{\i enable}{\b ) }{
\par Enable or disable a device interface
\par Defined in: D:/WDMBOOK/GENERIC/PLUGPLAY.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {One of the following standard status codes:
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_SUCCESS
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Operation was performed
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_INVALID_PARAMETER
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {No interface GUID by that name registered
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i guid}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of GUID for which an interface was previously registered by calling GenericRegisterInterface
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i enable}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {TRUE if interface should be enabled, FALSE if should be disabled
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericHandlePowerIoctl
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericHandlePowerIoctl(PGENERIC_EXTENSION}{ }{\i pdx}{\b , PIRP}{ }{\i Irp}{\b ) }{
\par Handle power management I/O control request
\par Defined in: D:/WDMBOOK/GENERIC/POWER.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard status code. STATUS_INVALID_DEVICE_REQUEST means that this IRP doesn't contain a generic power management IRP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i Irp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {IRP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Caller should already have acquired the remove lock it uses. On return, caller should complete the IRP no matter what status we return.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericIdleDevice
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericIdleDevice(PGENERIC_EXTENSION}{ }{\i pdx}{\b , DEVICE_POWER_STATE}{ }{\i state}{\b , BOOLEAN wait) }{
\par Power device down
\par Defined in: D:/WDMBOOK/GENERIC/POWER.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard status code
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i state}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Device power state to set
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i wait}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {(Optional) TRUE if want to wait for operation to finish, FALSE otherwise. The default is FALSE.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Use this function to force the device into a low power state in response to an end-user request to idle the device immediately
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericMarkDeviceBusy
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b GenericMarkDeviceBusy(PGENERIC_EXTENSION}{ }{\i pdx}{\b ) }{
\par Indicate device is not idle
\par Defined in: D:/WDMBOOK/GENERIC/POWER.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Call this function to perform a PoSetDeviceBusy in order to forestall an idle power-down
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericRegisterForIdleDetection
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID}{ }{\b GenericRegisterForIdleDetection(PGENERIC_EXTENSION}{ }{\i pdx}{\b , ULONG}{ }{\i ConservationTimeout}{\b , ULONG}{ }{\i PerformanceTimeout}{\b , DEVICE_POWER_STATE}{ 
}{\i state}{\b ) }{
\par Register device for idle detection
\par Defined in: D:/WDMBOOK/GENERIC/POWER.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i ConservationTimeout}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Timeout (in seconds) to apply when conserving power
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i PerformanceTimeout}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Timeout (in seconds) to apply when maximizing performance
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i state}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Device power state to enter when timeout expires with no call to GenericMarkDeviceBusy
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericRegisterInterface
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericRegisterInterface(PGENERIC_EXTENSION}{ }{\i pdx}{\b , const GUID*}{ }{\i guid}{\b ) }{
\par Register a device interface
\par Defined in: D:/WDMBOOK/GENERIC/PLUGPLAY.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard status code, which may be one of these, among others:
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_SUCCESS
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Operation was performed
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_INVALID_PARAMETER
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {An interface for this GUID has already been registered for this device.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i guid}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of interface GUID
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericSaveRestoreComplete
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b GenericSaveRestoreComplete(PVOID}{ }{\i context}{\b ) }{
\par Completion routine for device context save/restore operations
\par Defined in: D:/WDMBOOK/GENERIC/POWER.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i context}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Context parameter supplied in GENERIC's call to your SaveDeviceContext or RestoreDeviceContext function.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Call this function from the completion routine for the operations you initiate in your SaveDeviceContext or RestoreDeviceContext routine.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericSetDeviceState
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b GenericSetDeviceState(PGENERIC_EXTENSION}{ }{\i pdx}{\b , PNP_DEVICE_STATE}{ }{\i pnpstate}{\b ) }{
\par Report change in device status
\par Defined in: D:/WDMBOOK/GENERIC/PLUGPLAY.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pnpstate}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {New PnP state flags (see doc for PNP_DEVICE_STATE)
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {The client driver must synchronize calls to this routine to prevent ree
ntrance. The state that gets reported in the eventual IRP_MN_QUERY_PNP_DEVICE_STATE includes just those flag bits that have changed since the last call to this routine. This fact allows you to set PNP_DEVICE_NOT_DISABLEABLE one time and clear it another.

\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericUncacheControlRequest
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI PIRP GENERIC_EXPORT}{ }{\b GenericUncacheControlRequest(PGENERIC_EXTENSION}{ }{\i pdx}{\b , PIRP*}{ }{\i pIrp}{\b ) }{
\par Remove asynchronous I/O control request from the cache
\par Defined in: D:/WDMBOOK/GENERIC/CONTROL.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Pointer to previously cached IRP, or NULL if none was cached
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Generic.sys device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pIrp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Pointer cell where IRP was cached by GenericCacheControlRequest
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {The main purpose of this routine is remove the IRP from the cache in preparation for completing it.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericWakeupControl
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericWakeupControl(PGENERIC_EXTENSION}{ }{\i pdx}{\b , enum WAKEFUNCTION}{ }{\i wf}{\b ) }{
\par Control device wakeup functionality
\par Defined in: D:/WDMBOOK/GENERIC/POWER.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard status code, which may include the following (among others):
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_SUCCESS
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Requested change to wakeup enable state was made
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_INVALID_DEVICE_REQUEST
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Device doesn't support system wakeup, or invalid "wf" code
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i wf}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Code indicating action to take:
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {EnableWakeup
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Enable system wakeup functionality
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {DisableWakeup
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Disable system wakeup functionality
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {ManageWaitWake
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Request or cancel WAIT_WAKE IRP, as appropriate to enable state
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {CancelWaitWake
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Unconditionally cancel WAIT_WAKE IRP if one is pending
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GenericWakeupFromIdle
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b GenericWakeupFromIdle(PGENERIC_EXTENSION}{ }{\i pdx}{\b , BOOLEAN}{ }{\i wait}{\b ) }{
\par Force device wakeup from idle state
\par Defined in: D:/WDMBOOK/GENERIC/POWER.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard status code
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of generic device extension
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i wait}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {TRUE if want to wait for power-up to finish, FALSE otherwise
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Call this function prior to StartPacket if the device might have been powered-down due to idleness. I
f the device hasn't been powered down, this function returns immediately. Otherwise, it sends a device SET_POWER request.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GetCurrentIrp
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI PIRP GENERIC_EXPORT}{ }{\b GetCurrentIrp(PDEVQUEUE}{ }{\i pdq}{\b ) }{
\par Determine the current IRP for a queue
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {The IRP most recently passed to the StartIo routine, or NULL if the device is not busy.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {This function serves the same purpose as dereferencing a device object's CurrentIrp pointer in the "standard model"
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GetSizeofGenericExtension
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI ULONG GENERIC_EXPORT}{ }{\b GetSizeofGenericExtension(void) }{
\par Determine the size of the GENERIC.SYS device extension
\par Defined in: D:/WDMBOOK/GENERIC/DRIVERENTRY.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Number of bytes needed by GENERIC.SYS in your device extension.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Call this function before creating your device object.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Example
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {The following example illustrates how to specify the device extension size when you call IoCreateDevice
\par }\pard\plain \s16\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\adjustright \f2\fs16 {ULONG dxsize = (sizeof(DEVICE_EXTENSION) + 7) & ~7;
\par ULONG xsize = dxsize + GetSizeofGenericExtension();
\par PDEVICE_OBJECT fdo;
\par NTSTATUS status = IoCreateDevice(DriverObject, xsize, ..., &fdo);
\par PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fdo->DeviceObject;
\par PGENERIC_EXTENSION pgx = (PGENERIC_EXTENSION) ((PUCHAR) pdx + dxsize);
\par 
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {InitializeGenericExtension
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b InitializeGenericExtension(PGENERIC_EXTENSION}{ }{\i pdx}{\b , PGENERIC_INIT_STRUCT}{ }{\i isp}{\b ) }{
\par Initialize GENERIC.SYS for a new device object
\par Defined in: D:/WDMBOOK/GENERIC/DRIVERENTRY.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard status code, such as:
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_INVALID_PARAMETER
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Invalid parameter in initialization structure
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_SUCCESS
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Normal result
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdx}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i isp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Structure containing initialization parameters
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Call this function from your AddDevice function to register to use GENERIC.SYS for handling standard WDM driver functions
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Example
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {The following example illustrates how to initialize your driver to use GENERIC.SYS:
\par }\pard\plain \s16\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\adjustright \f2\fs16 {NTSTATUS AddDevice(...)
\par   \{
\par   ULONG dxsize = (sizeof(DEVICE_EXTENSION) + 7) & ~7;
\par   ULONG xsize = dxsize + GetSizeofGenericExtension();
\par   PDEVICE_OBJECT fdo;
\par   NTSTATUS status = IoCreateDevice(DriverObject, xsize, ..., &fdo);
\par   PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fdo->DeviceObject;
\par   PGENERIC_EXTENSION pgx = (PGENERIC_EXTENSION) ((PUCHAR) pdx + dxsize);
\par   GENERIC_INIT_STRUCT gis = \{sizeof(GENERIC_INIT_STRUCT)\};
\par   [initialize fields of "gis" structure]
\par   status = InitializeGenericExtension(pgx, &gis);
\par   \}
\par 
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {InitializeQueue
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b InitializeQueue(PDEVQUEUE}{ }{\i pdq}{\b , PDRIVER_STARTIO}{ }{\i StartIo}{\b ) }{
\par Initialize a device queue
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i StartIo}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Routine to call to start a request
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {IsWin98
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI BOOLEAN GENERIC_EXPORT}{ }{\b IsWin98(void) }{
\par Determine if we're running under Windows 98 or Windows 2000
\par Defined in: D:/WDMBOOK/GENERIC/DRIVERENTRY.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {TRUE if running under Windows 98, FALSE if under Windows 2000
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {This function calls IoIsWdmVersionAvailable to see if the OS supports WDM version 1.10. Win98 and Win98 2d ed support 1.00, whereas Win2K supports 1.10.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {OkayToRemove
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b BOOLEAN}{ }{\b OkayToRemove(PDEVICE_OBJECT}{ }{\i DeviceObject}{\b ) }{
\par Determine if it's okay to remove the device right now
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {TRUE if the device can be removed immediately, FALSE otherwise.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of the device object.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {GENERIC calls this function during the processing of IRP_MN_QUERY_REMOVE_DEVICE to determine if there's any reason why the device could not immediately be removed.
\par The name of this function is a placeholder for a function you define in your driver. You initialize the OkayToRemove field in the GENERIC_INIT_STRUCT to point to your function before you call InitializeGenericExtension.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {OkayToStop
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b BOOLEAN}{ }{\b OkayToStop(PDEVICE_OBJECT}{ }{\i DeviceObject}{\b ) }{
\par Determine if it's okay to stop the device right now
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {TRUE if the device can be stopped immediately, FALSE otherwise.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of the device object.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {GENERIC calls this function during the processing of IRP_MN_QUERY_STOP_DEVICE to determine if there's any reason
 why the device could not immediately be stopped. If your device can't be stopped because it's busy with a particular type of IRP, for example, you can return FALSE.
\par The name of this function is a placeholder for a function you define in your driver. You initialize the OkayToStop field in the GENERIC_INIT_STRUCT to point to your function before you call InitializeGenericExtension..
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {QueryPowerChange
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b BOOLEAN}{ }{\b QueryPowerChange(PDEVICE_OBJECT}{ }{\i DeviceObject}{\b , DEVICE_POWER_STATE}{ }{\i oldstate}{\b , DEVICE_POWER_STATE}{ }{\i newstate}{\b ) }{
\par Determine if a pending power change will be okay
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {TRUE if the proposed power change is permissible, FALSE if not.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of the device object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i oldstate}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {The current power state for the device
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i newstate}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {The proposed new power state for the device
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {GENERIC calls this routine as part of handling an IRP_MN_QUERY_POWER involving a proposed change in the device power state. You should provide the answer without blocking 
the current thread. Your function must be in nonpaged memory unless you know that the underlying IRP can never be sent at DISPATCH_LEVEL.
\par The name of this function is a placeholder for a function you define in your driver. You initialize the QueryPower field in the GENERIC_INIT_STRUCT to point to your function before you call InitializeGenericExtension.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {RemoveDevice
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b VOID}{ }{\b RemoveDevice(PDEVICE_OBJECT}{ }{\i DeviceObject}{\b ) }{
\par Destroy device object in response to IRP_MN_REMOVE_DEVICE
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of the device object
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {In general, the operations of RemoveDevice should be the opposite of the operations performed in AddDevice.
\par The name of this function is a placeholder for a function you define in your driver. You initialize the RemoveDevice field in the GENERIC_INIT_STRUCT to point to your function before you call InitializeGenericExtension..
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {RestartRequests
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b RestartRequests(PDEVQUEUE}{ }{\i pdq}{\b , PDEVICE_OBJECT}{ }{\i fdo}{\b ) }{
\par Unstall a queue
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i fdo}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of associated device object
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {This function undoes the effect of a previous call to StallRequests or CheckBusyAndStall
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {RestoreDeviceContext
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b VOID}{ }{\b RestoreDeviceContext(PDEVICE_OBJECT}{ }{\i DeviceObject}{\b , DEVICE_POWER_STATE}{ }{\i oldstate}{\b , DEVICE_POWER_STATE}{ }{\i newstate}{\b , PVOID}{ }{\i context}{\b ) }{

\par Restore device context following power up
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of the device object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i oldstate}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Old device power state
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i newstate}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {New device power state
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i context}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Context parameter to use in eventual call to GenericSaveRestoreComplete
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {GENERIC calls this function to afford you an opportunity to restore any device context 
information that should be restored after power is restored to your device. You should initiate any required I/O operations without waiting for them to complete. When all operations finish, call GenericSaveRestoreComplete. Your function must be in nonpage
d memory unless you know that the underlying IRP can never be sent at DISPATCH_LEVEL.
\par The name of this function is a placeholder for a function you define in your driver. You initialize the SaveDeviceContext field in the GENERIC_INIT_STRUCT to point to your function before you call InitializeGenericExtension.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {SaveDeviceContext
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b VOID}{ }{\b SaveDeviceContext(PDEVICE_OBJECT}{ }{\i DeviceObject}{\b , DEVICE_POWER_STATE}{ }{\i oldstate}{\b , DEVICE_POWER_STATE}{ }{\i newstate}{\b , PVOID}{ }{\i context}{\b ) }{
\par Save device context in preparation for powering down
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of the device object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i oldstate}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Old device power state
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i newstate}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {New device power state
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i context}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Context parameter to use in eventual call to GenericSaveRestoreComplete
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {GENERIC calls
 this function to afford you an opportunity to save any device context information that will be lost when the device enters the specified new power state. You should initiate any required I/O operations without waiting for them to complete. When all opera
tions finish, call GenericSaveRestoreComplete. Your function must be in nonpaged memory unless you know that the underlying IRP can never be sent at DISPATCH_LEVEL.
\par The name of this function is a placeholder for a function you define in your driver. You initialize the SaveDeviceContext field in the GENERIC_INIT_STRUCT to point to your function before you call InitializeGenericExtension.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {StallRequests
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b StallRequests(PDEVQUEUE}{ }{\i pdq}{\b ) }{
\par Stall a queue
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {This function prevents requests from being sent to the StartIo routine.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {StallRequestsAndNotify
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI NTSTATUS GENERIC_EXPORT}{ }{\b StallRequestsAndNotify(PDEVQUEUE}{ }{\i pdq}{\b , PQNOTIFYFUNC}{ }{\i notify}{\b , PVOID}{ }{\i context}{\b ) }{
\par Stall queue and provide notification when current IRP completes
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard status code, as follows:
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_SUCCESS
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Queue is stalled and device was idle, so callback function won't be called.
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_PENDING
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Queue is stalled but device isn't idle yet.
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {STATUS_INVALID_DEVICE_REQUEST
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {A StallRequestsAndNotify is already pending for this queue
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i notify}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of notification function
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i context}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Context value to be used as the only argument to the notify function
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {StartDevice
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b NTSTATUS}{ }{\b StartDevice(PDEVICE_OBJECT}{ }{\i DeviceObject}{\b , PCM_PARTIAL_RESOURCE_LIST}{ }{\i raw}{\b , PCM_PARTIAL_RESOURCE_LIST}{ }{\i translated}{\b ) }{
\par Configure device during IRP_MN_START_DEVICE.
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Standard status code
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of the device object.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i raw}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {"Raw" (i.e., untranslated) resources assigned by the PnP Manager.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i translated}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Translated resources assigned by the PnP Manager.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {
The name of this function is a placeholder for a function you define in your driver. You initialize the StartDevice field in the GENERIC_INIT_STRUCT to point to your function before you call InitializeGenericExtension..
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {StartIo
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b VOID}{ }{\b StartIo(PDEVICE_OBJECT}{ }{\i DeviceObject}{\b , PIRP}{ }{\i Irp}{\b ) }{
\par Start the next I/O operation
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of the device object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i Irp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {An IRP to be started
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {GENERIC passes IRPs one at a time to this routine when you c
all StartPacket or StartNextPacket. Your function looks like a regular StartIo function in the "Standard Model" for IRP processing, except that it contains no logic for dealing with a cancelled IRP.
\par The name of this function is a placeholder for a function you define in your driver. You initialize the StartIo field in the GENERIC_INIT_STRUCT to point to your function before you call InitializeGenericExtension.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {StartNextPacket
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI PIRP GENERIC_EXPORT}{ }{\b StartNextPacket(PDEVQUEUE}{ }{\i pdq}{\b , PDEVICE_OBJECT}{ }{\i fdo}{\b ) }{
\par Start the next queued request
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Return Value
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Address of IRP with which device was previously busy (if any)
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i fdo}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of associated device object
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {StartPacket
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b StartPacket(PDEVQUEUE}{ }{\i pdq}{\b , PDEVICE_OBJECT}{ }{\i fdo}{\b , PIRP}{ }{\i Irp}{\b , PDRIVER_CANCEL}{ }{\i cancel}{\b ) }{
\par Queue or start a new request
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i fdo}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of associated device object
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i Irp}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {IRP to start or queue
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i cancel}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Cancel routine
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {If the device is currently idle and the queue isn't stalled, this function sends the new IRP to the StartIo routine. Otherwise, it puts the IRP onto the queue.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {StopDevice
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b VOID}{ }{\b StopDevice(PDEVICE_OBJECT}{ }{\i DeviceObject}{\b , BOOLEAN}{ }{\i OkTouch}{\b ) }{
\par Deconfigure device during IRP_MN_STOP_DEVICE (and at other times).
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of the device object.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i OkTouch}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {TRUE if it will be okay to communicate with the hardware, FALSE otherwise.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {In general, the operations of StopDevice should be the opposite of the operations performed in StartDevice.
\par The name of this function is a placeholder for a function you define in your driver. You initialize the StopDevice field in the GENERIC_INIT_STRUCT to point to your function before you call InitializeGenericExtension..
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {\cf6 Developer Notes
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\cf6 StopDevice can be called multiple times for a single call to StartDevice.
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {WaitForCurrentIrp
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {\b GENERICAPI VOID GENERIC_EXPORT}{ }{\b WaitForCurrentIrp(PDEVQUEUE}{ }{\i pdq}{\b ) }{
\par Wait for the current IRP to finish
\par Defined in: D:/WDMBOOK/GENERIC/DEVQUEUE.CPP
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Parameters
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\i pdq}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {If the device is currently busy, this function waits for the IRP to complete
\par }\pard\plain \s24\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \adjustright \fs8\cf8 {
\par }\pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult0\keepn\widctlpar\outlinelevel0\adjustright \b\fs40 {GENERIC_INIT_STRUCT Structure
\par }\pard\plain \s16\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\adjustright \f2\fs16 {typedef struct \{
\par \tab ULONG Size;
\par \tab PDEVICE_OBJECT DeviceObject;
\par \tab PDEVICE_OBJECT Pdo;
\par \tab PDEVICE_OBJECT Ldo;
\par \tab PGENERIC_REMOVE_LOCK RemoveLock;
\par \tab PDEVQUEUE DeviceQueue;
\par \tab PDRIVER_STARTIO StartIo;
\par \tab PSTART_DEVICE StartDevice;
\par \tab PSTOP_DEVICE StopDevice;
\par \tab PREMOVE_DEVICE RemoveDevice;
\par \tab UNICODE_STRING DebugName;
\par \tab ULONG Flags;
\par \tab PQUERYFUNCTION OkayToStop;
\par \tab PQUERYFUNCTION OkayToRemove;
\par \tab PQUERYPOWERFUNCTION QueryPower;
\par \tab PCONTEXTFUNCTION SaveDeviceContext;
\par \tab PCONTEXTFUNCTION RestoreDeviceContext;
\par \tab DEVICE_POWER_STATE PerfBoundary;
\par \} GENERIC_INIT_STRUCT;
\par 
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {Parameter structure for InitializeGenericExtension
\par Defined in: D:/WDMBOOK/GENERIC/GENERIC.H
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Members
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b Size}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Size of this structure. Initialize this to sizeof(GENERIC_INIT_STRUCT).
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b DeviceObject}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {The device object being registered. This would generally be returned by IoCreateDevice.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b Pdo}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {The PDO below this device object. This would generally be the same as the 2d argument to AddDevice.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b Ldo}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Immediately lower device object. Set this equal to the return value from IoAttachDeviceToDeviceStack.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b RemoveLock}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of remove lock in containing device extension (optional). InitializeGenericExtension will initialize this object for you. Specify NULL if you're not using an IO_REMOVE_LOCK.

\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b DeviceQueue}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Address of queue object for read/write IRPs (optional). InitializeGenericExtension will initialize this object for you. Specify NULL if you don't queue read/write IRPs.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b StartIo}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Start I/O routine for reads & writes (required only if DeviceQueue non-NULL). See the entry for StartIo for an explanation of the calling sequence to this routine.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b StartDevice}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Routine to initialize device configuration. See the entry for StartDevice for an explanation of the calling sequence to this routine.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b StopDevice}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Routine to release device configuration. See the entry for StopDevice for an explanation of the calling sequence to this routine.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b RemoveDevice}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Routine to remove device object. See the entry for RemoveDevice for an explanation of the calling sequence to this routine.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b DebugName}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Name to use in debug messages.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b Flags}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Option flags. Zero or more of the following values:
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {GENERIC_AUTOLAUNCH
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Register and enable a device interface so that the AutoLaunch service will launch an application when this device starts.
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {GENERIC_USAGE_PAGING
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {This device supports the paging-file usage notification.
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {GENERIC_USAGE_DUMP
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {This device supports the dump-file usage notification.
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {GENERIC_USAGE_HIBERNATE
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {This device supports the hibernate-file usage notification.
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {GENERIC_PENDING_IOCTLS
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {The driver may cache asynchronous DeviceIoControl operations.
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {GENERIC_SURPRISE_REMOVAL_OK
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Surprise removal of the device is okay.
\par }\pard\plain \s21\li280\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {GENERIC_IDLE_DETECT
\par }\pard\plain \s23\li560\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Device supports GENERIC's idle detection scheme.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b OkayToStop}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {
Routine to decide whether it's okay to stop device now (optional). See the entry for OkayToStop for an explanation of the calling sequence to this routine. If you specify NULL, GENERIC assumes it's always okay to stop your device.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b OkayToRemove}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Routine to d
ecide whether it's okay to remove device now (optional). See the entry for OkayToRemove for an explanation of the calling sequence to this routine. If you specify NULL, GENERIC assumes it's always okay to remove your device.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b QueryPower}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Routine to decide wh
ether a proposed device power change is okay (optional). See the entry for QueryPower for an explanation of the calling sequence to this routine. If you specify NULL, GENERIC assumes that all power changes are okay unless your device is in the path of a p
aging, dump, or hibernation file.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b SaveDeviceContext}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {
Routine to save device context before power down (optional). See the entry for SaveDeviceContext for an explanation of the calling sequence to this routine. If you specify NULL, GENERIC will power the devi
ce down without affording you a chance to save any context information.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b RestoreDeviceContext}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {Routine to restore device context after power up (optional). See the entry for RestoreDeviceContext for an explanation of the calling sequence to this routine. If 
you specify NULL, GENERIC will restore power to the device without affording you a chance to restore any context information.
\par }\pard\plain \s20\sl-240\slmult0\keepn\widctlpar\adjustright \fs21 {\b PerfBoundary}{
\par }\pard\plain \s22\li280\sa80\sl-240\slmult0\widctlpar\adjustright \fs21 {(Optional) Power state below which context restore inordinately expensive. Leave zero if context restore not ever a performance issue with this device.
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Comments
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {You create an instance of this structure and pass its address as an argument when you call InitializeGenericExtension
\par }\pard\plain \s19\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\adjustright \b\f1\fs21 {Example
\par }\pard\plain \sa160\sl240\slmult0\widctlpar\adjustright \fs21 {The following example illustrates how you might initialize this structure:
\par }\pard\plain \s16\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\adjustright \f2\fs16 {GENERIC_INIT_STRUCT gis;
\par gis.Size = sizeof(GENERIC_INIT_STRUCT);
\par gis.DeviceObject = fdo;
\par gis.Pdo = pdo;
\par gis.Ldo = pdx->LowerDeviceObject;
\par gis.RemoveLock = &pdx->RemoveLock;
\par gis.DeviceQueue = &pdx->dqReadWrite;
\par gis.StartIo = StartIo;
\par gis.StartDevice = StartDevice;
\par gis.StopDevice = StopDevice;
\par gis.RemoveDevice = RemoveDevice;
\par RtlInitUnicodeString(&gis, DebugName, L"MYDRIVER");
\par gis.Flags = GENERIC_SURPRISE_REMOVAL_OK | GENERIC_IDLE_DETECT;
\par gis.OkayToStop = OkayToStop;
\par gis.OkayToRemove = OkayToRemove;
\par 
\par }}